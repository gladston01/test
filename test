import groovy.json.JsonSlurper
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption

// Define the CSV file path
def csvFilePath = '/path/to/your/output.csv'

// Read the response from the previous sampler
def response = prev.getResponseDataAsString()

// Parse the JSON response
def jsonSlurper = new JsonSlurper()
def jsonResponse = jsonSlurper.parseText(response)

// Extract the "data" array
def jsonResponse1 = jsonResponse.data

// Helper function to check if all fields in a row are empty
def isRowEmpty(row) {
    return row instanceof Map && row.values().every { value ->
        value == null || value.toString().trim().isEmpty()
    }
}

// Check if the entire "data" array contains only empty rows
def allRowsEmpty = jsonResponse1 != null && jsonResponse1.every { row ->
    isRowEmpty(row)
}

// Control the loop based on whether all rows are empty
if (jsonResponse1 == null || jsonResponse1.isEmpty() || allRowsEmpty) {
    vars.put("continueLoop", "false")  // Stop the loop
    log.info("Stopping loop: No valid data remaining.")
} else {
    vars.put("continueLoop", "true")   // Continue the loop
    log.info("Valid data found. Continuing loop.")

    // Create the CSV file if it doesn't exist
    if (!Files.exists(Paths.get(csvFilePath))) {
        Files.createFile(Paths.get(csvFilePath))
        
        // Write the header row to the CSV (use keys from the first row of data)
        def header = jsonResponse1[0].keySet().join(",") + "\n"
        Files.write(Paths.get(csvFilePath), header.getBytes(), StandardOpenOption.APPEND)
    }

    // Iterate over each row of data and write it to the CSV
    jsonResponse1.each { row ->
        if (row instanceof Map) {  // Ensure the row is a Map object
            // Convert the row map values to a comma-separated string
            def csvRow = row.values().collect { it == null ? "" : it.toString().trim() }.join(",") + "\n"
            
            // Append the row to the CSV file
            Files.write(Paths.get(csvFilePath), csvRow.getBytes(), StandardOpenOption.APPEND)
        } else {
            log.warn("Row is not a Map: ${row}")
        }
    }
}
