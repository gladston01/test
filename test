import sys
from lxml import etree
import re
import argparse

# Function to extract error messages from relevant tags
def extract_error_message(failure_html):
    # Parse the HTML content using lxml
    parser = etree.HTMLParser()
    tree = etree.HTML(failure_html, parser=parser)

    # Define the list of specific error tags
    error_tags = [
        ".//*[contains(local-name(), 'errorText')]",  # Handles dynamic prefixes like <ns1:errorText>
        ".//messageText",
        ".//message",
        ".//SerErrorMessage",
    ]

    # Search for specific error tags
    for xpath in error_tags:
        found_elements = tree.xpath(xpath)
        if found_elements:
            # Extract and clean text from found elements
            error_messages = [etree.tostring(e, method="text", encoding="unicode").strip() for e in found_elements if e.text]
            if error_messages:
                return " | ".join(error_messages)

    # If no specific error tags are found, return a default message
    return "No meaningful error message found."

# Set up argument parser
parser = argparse.ArgumentParser(description="Extract failure details from an HTML file.")
parser.add_argument("--html-location", required=True, help="Path to the HTML file containing failure details.")
args = parser.parse_args()

input_file = args.html_location

# Read the input HTML file
try:
    with open(input_file, 'r', encoding='utf-8') as file:
        html_content = file.read()
except FileNotFoundError:
    print(f"Error: File '{input_file}' not found.")
    sys.exit(1)

# Parse the HTML content using lxml
parser = etree.HTMLParser()
tree = etree.HTML(html_content, parser=parser)

# Find all failure rows
failure_rows = tree.xpath("//tr[contains(@class, 'Failure')]")

# Prepare to write to output file
output_file = 'extracted_failures.txt'

with open(output_file, 'w', encoding='utf-8') as output:
    for row in failure_rows:
        # Extract the test case name
        test_case_name_elem = row.xpath(".//td[2]/a")
        test_case_name = test_case_name_elem[0].get("name", "Unknown Test Case") if test_case_name_elem else "Unknown Test Case"

        # Extract all test step names and their failure details
        failure_details_elem = row.xpath(".//td[4]")  # Adjusting for the fourth column (0-indexed)
        if not failure_details_elem:
            output.write(f"Warning: No failure details found for Test Case: {test_case_name}\n")
            output.write("-" * 40 + "\n")
            continue

        failure_details_html = etree.tostring(failure_details_elem[0], encoding="unicode", method="html")
        test_step_matches = re.findall(r'TestStep:\s*(\w+)', failure_details_html)

        if not test_step_matches:
            output.write(f"Warning: No test steps found for Test Case: {test_case_name}\n")
            output.write("-" * 40 + "\n")
            continue

        for test_step_name in test_step_matches:
            # Extract the failure reason for each test step
            failure_reason = extract_error_message(failure_details_html)

            # Write the extracted information to the output file
            output.write(f"Test Case Name: {test_case_name}\n")
            output.write(f"Test Step Name: {test_step_name}\n")
            output.write(f"Failure Reason: {failure_reason}\n")
            output.write("-" * 40 + "\n")

print(f"Extraction completed. Check the file '{output_file}' for details.")
