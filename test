import groovy.json.JsonSlurper
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption

// Define the CSV file path
def csvFilePath = '/path/to/your/output.csv'

// Read the response from the previous sampler
def response = prev.getResponseDataAsString()

// Parse the JSON response
def jsonSlurper = new JsonSlurper()
def jsonResponse = jsonSlurper.parseText(response)

// Extract the "data" array
def jsonResponse1 = jsonResponse.data

// Increment the loop counter
def loopCounter = vars.get("loopCounter") as Integer ?: 0
loopCounter += 1
vars.put("loopCounter", loopCounter.toString())

log.info("Processing loop iteration: ${loopCounter}")

// Create the CSV file if it doesn't exist
if (!Files.exists(Paths.get(csvFilePath))) {
    Files.createFile(Paths.get(csvFilePath))
    
    // Write the header row to the CSV (use keys from the first row of data if available)
    if (jsonResponse1 != null && !jsonResponse1.isEmpty() && jsonResponse1[0] instanceof Map) {
        def header = jsonResponse1[0].keySet().join(",") + "\n"
        Files.write(Paths.get(csvFilePath), header.getBytes(), StandardOpenOption.APPEND)
    } else {
        log.warn("No valid data in the response to determine header.")
    }
}

// Iterate over each row of data and write it to the CSV
if (jsonResponse1 != null && !jsonResponse1.isEmpty()) {
    jsonResponse1.each { row ->
        // Convert LinkedHashMap$Entry to a Map if necessary
        if (row instanceof Map.Entry) {
            row = [(row.key): row.value]
        }

        if (row instanceof Map) {  // Ensure the row is now a Map object
            def csvRow = row.values().collect { it == null ? "" : it.toString().trim() }.join(",") + "\n"
            Files.write(Paths.get(csvFilePath), csvRow.getBytes(), StandardOpenOption.APPEND)
            log.info("Row written to CSV: ${csvRow.trim()}")
        } else {
            log.warn("Skipping unexpected row type: ${row.getClass().name} - ${row}")
        }
    }
} else {
    log.warn("No data rows available in the response.")
}

// Set the loop control variable to stop after 5000 iterations
def maxLoops = 5000
if (loopCounter >= maxLoops) {
    vars.put("continueLoop", "false")
    log.info("Stopping loop: Reached max loop count (${maxLoops}).")
} else {
    vars.put("continueLoop", "true")
    log.info("Continuing loop: Current iteration (${loopCounter}).")
}
